# 工作原理

## 基本概念

在开发`Nodejs`应用时，当需要在数据库中存储树时，常见的存储结构有以下几种：

- 邻接列表结构
- 路径枚举结构
- 嵌套树结构
- 闭包表结构

以上算法各有优缺点，应该根据实际的应用场景选择合适的算法。

`嵌套树模型（Nested Set Model）`也被称为`左右值`模型，它是一种用于存储树形结构数据的方法，通过两个字段（通常被称为 'lft' 和 'rgt'）来表示节点在树中的位置。

在嵌套树模型中，每个节点的`lft`值都小于其所有子节点的`lft`值，`rgt`值都大于其所有子节点的 `rgt` 值。这样，我们可以通过一个简单的查询来获取一个节点的所有后代，只需要查找`lft` 和 `rgt` 值在这个范围内的所有节点即可。

嵌套树模型的左右值分布方式是通过`深度优先遍历（Depth-First Search）`来确定的。在遍历过程中，每当进入一个节点时，就分配一个 `lft` 值，每当离开一个节点时，就分配一个 `rgt` 值。这样，每个节点的 `lft` 和 `rgt` 值就形成了一个区间，这个区间内的所有值都对应该节点的子节点。

![](./lr.png)

例如，下面是一个嵌套树模型的例子：


| id | leftValue | rightValue | name |
|----|-----|-----|------|
| 1  | 1   | 14  | root |
| 2  | 2   | 9   | A    |
| 3  | 10  | 11  | B    |
| 4  | 12  | 13  | C    |
| 5  | 3   | 4   | A-1  |
| 6  | 5   | 6   | A-2  |
| 7  | 7   | 8   | A-3  |
 
这个表表示了如下的树形结构：

<LiteTree>
- root
    - A
        - A-1
        - A-2
        - A-3
    - B
    - C
</LiteTree>

## 扩展

`FlexTree`就是基于`左右值`算法的树存储管理组件,采用`Typescript`开发，适用于任意数据库场景，封装了各种易用的API。

`FlexTree`在`左右值`算法的基础上，增加了`level`字段，用于表示节点的层级。通过`level`字段，我们可以更方便的获取树的层级结构。如下：

| id | `level` | leftValue | rightValue | name |
|----|---|-----|-----|------|
| 1  | `0` |  1   | 14  | root |
| 2  | `1` | 2   | 9   | A    |
| 3  | `1` | 10  | 11  | B    |
| 4  | `1` | 12  | 13  | C    |
| 5  | `2` | 3   | 4   | A-1  |
| 6  | `2` | 5   | 6   | A-2  |
| 7  | `2` | 7   | 8   | A-3  |



## 方案对比

在数据库中存储树形结构数据时，比较常见用的方案是几种：

- 邻接列表结构
- 路径枚举结构
- 闭包表结构
- 嵌套树结构

### 与邻接列表结构对比

邻接列表结构每个节点都有一个指向其父节点(`pid`)的引用。如下：

| id | pid | name |
|----|-----------|------|
| 1  | NULL      | root |
| 2  | 1         | A    |
| 3  | 1         | B    |
| 4  | 1         | C    |
| 5  | 2         | A-1  |
| 6  | 2         | A-2  |
| 7  | 2         | A-3  |


这种方法简单直观，也是最容易理解和常用的方法，但是在查询时需要递归查询，性能较差。

比如我们要实现以下方法：

- 查询某个节点的所有后代节点
- 查询某个节点的所有祖先节点
- 移动某个子树到另一个节点下
- 删除某个节点及其后代子树

这些操作均无法通过简单的`1-N`条`SQL`语句实现，需要应用层进行**递归查询**，树的层级越多，性能较差。

### 与路径枚举结构对比

正因为邻接列表结构的递归性能问题，所以有了路径枚举结构。路径枚举结构是在邻接列表结构的基础上，增加了一个`path`字段，用于存储节点的路径。如下：


| id | path     | name |
|----|----------|------|
| 1  | /root       | root |
| 2  | /root/A     | A    |
| 3  | /root/B     | B    |
| 4  | /root/C     | C    |
| 5  | /root/A/A-1   | A-1  |
| 6  | /root/A/A-2   | A-2  |
| 7  | /root/A/A-3   | A-3  |

此种方案的优点是：查询某个节点的所有后代节点时，只需要查询`path`字段即可，不需要递归查询。但是，当树的层级较多时，但是也存在缺点l

- 查询操作主要是对`path`字符串的操作，性能较差
- 路径可能变得很长，树的层级受限，普通的`VARCHAR`可能不够，需要使用`TEXT`。  
- 选择哪个字段拼接`path`是个问题.
    - 如果选择`name`作为`path`字段，当`name`字段值存在重名、特殊字符、变更时，会导致`path`字段不唯一或异常。因此作为`path`字段的字段应该尽量是是唯一的、简短的、变化很少的，且不包含特殊字符。
    - 如果选择`id`(`pk`)组合`path`字段，由于`pk`具有唯一性并且比较稳定，所以是比较适合作为`path`字段的。但是如果`id`字段是`uuid`类型，那么就导致`path`字段变得很长，查询效率也相应变低。 
    







